<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Cassandra: Basic Operations and Architecture</title>
<link rel="stylesheet" href="../css/style.css">
</head>
<body>
<main>
<p>This is the second post in the NoSQL Databases series, with a brief description on the basic operations (such as insertion, retrieval, indexing…), and complete execution along with the data model / architecture.</p>
<div class="date-created-modified">Created 2020-03-05<br>
Modified 2020-03-24</div>
<p>Other posts in this series:</p>
<ul>
<li><a href="/blog/ribw/nosql-databases-an-introduction/">Cassandra: an Introduction</a></li>
<li><a href="/blog/ribw/nosql-databases-basic-operations-and-architecture/">Cassandra: Basic Operations and Architecture</a> (this post)</li>
</ul>
<hr />
<p>Cassandra uses it own Query Language for managing the databases, it is known as **CQL **(<strong>Cassandra Query Language</strong>). Cassandra stores data in <strong><em>tables</em></strong>, as in relational databases, and these tables are grouped in <strong><em>keyspaces</em></strong>. A keyspace defines a number of options that applies to all the tables it contains. The most used option is the **replication strategy. **It is recommended to have only one keyspace by application.</p>
<p>It is important to mention that <strong>tables and keyspaces</strong> are** case insensitive**, so myTable is equivalent to mytable, but it is possible to <strong>force case sensitivity</strong> using <strong>double-quotes</strong>.</p>
<p>To begin with the basic operations it is necessary to deploy Cassandra:</p>
<ol>
<li>Open a terminal in the root of the Apache Cassandra folder downloaded in the previous post.</li>
<li>Run the command:</li>
</ol>
<pre><code>$ bin/cassandra
</code></pre>
<p>Once Cassandra is deployed, it is time to open a** CQL Shell**, in <strong>other terminal</strong>, with the command: </p>
<pre><code>$ bin/cqlsh
</code></pre>
<p>It is possible to check if Cassandra is deployed if the SQL Shell prints the next message:</p>
<p><img src="uwqQgQte-cuYb_pePFOuY58re23kngrDKNgL1qz4yOfnBDZkqMIH3fFuCrye.png" alt="" />
<em>CQL Shell</em></p>
<h2 class="title" id="create_insert"><a class="anchor" href="#create_insert">¶</a>Create/Insert</h2>
<h3 id="ddl_data_definition_language_"><a class="anchor" href="#ddl_data_definition_language_">¶</a>DDL (Data Definition Language)</h3>
<h4 id="create_keyspace"><a class="anchor" href="#create_keyspace">¶</a>Create keyspace</h4>
<p>A keyspace is created using a **CREATE KEYSPACE **statement:</p>
<pre><code>$ **CREATE** KEYSPACE [ **IF** **NOT** **EXISTS** ] keyspace_name **WITH** options;
</code></pre>
<p>The supported “<strong>options</strong>” are:</p>
<ul>
<li>“<strong>replication</strong>”: this is **mandatory **and defines the <strong>replication strategy</strong> and the <strong>replication factor</strong> (the number of nodes that will have a copy of the data). Within this option there is a property called “<strong>class</strong>” in which the <strong>replication strategy</strong> is specified (“SimpleStrategy” or “NetworkTopologyStrategy”)</li>
<li>“<strong>durable_writes</strong>”: this is <strong>not mandatory</strong> and it is possible to use the <strong>commit logs for updates</strong>.
Attempting to create an already existing keyspace will return an error unless the **IF NOT EXISTS **directive is used. </li>
</ul>
<p>The example associated to this statement is create a keyspace with name “test_keyspace” with “SimpleStrategy” as “class” of replication and a “replication_factor” of 3.</p>
<pre><code>**CREATE** KEYSPACE test_keyspace
    **WITH** **replication** = {'class': 'SimpleStrategy',
                        'replication_factor' : 3};
</code></pre>
<p>The **USE **statement allows to <strong>change</strong> the current <strong>keyspace</strong>. The syntax of this statement is very simple: </p>
<pre><code>**USE** keyspace_name;
</code></pre>
<p><img src="RDWIG2RwvEevUFQv6TGFtGzRm4_9ERpxPf0feriflaj3alvWw3FEIAr_ZdF1.png" alt="" />
<em>USE statement</em></p>
<p>It is also possible to get the metadata from a keyspace with the **DESCRIBE **statement.</p>
<pre><code>**DESCRIBE** KEYSPACES | KEYSPACE keyspace_name;
</code></pre>
<h4 id="create_table"><a class="anchor" href="#create_table">¶</a>Create table</h4>
<p>Creating a new table uses the **CREATE TABLE **statement:</p>
<pre><code>**CREATE** **TABLE** [ **IF** **NOT** **EXISTS** ] table_name
    '('
        column_definition
        ( ',' column_definition )*
        [ ',' **PRIMARY** **KEY** '(' primary_key ')' ]
    ')' [ **WITH** table_options ];
</code></pre>
<p>With “column_definition” as: column_name cql_type [ STATIC ] [ PRIMARY KEY]; “primary_key” as: partition_key [ ‘,’ clustering_columns ]; and “table_options” as: COMPACT STORAGE [ AND table_options ] or CLUSTERING ORDER BY ‘(‘ clustering_order ‘)’ [ AND table_options ] or “options”.</p>
<p>Attempting to create an already existing table will return an error unless the <strong>IF NOT EXISTS</strong> directive is used.</p>
<p>The <strong>CQL types</strong> are described in the References section.</p>
<p>For example, we are going to create a table called “species_table” in the keyspace “test_keyspace” in which we will have a “species” text (as PRIMARY KEY), a “common_name” text, a “population” varint, a “average_size” int and a “sex” text. Besides, we are going to add a comment to the table: “Some species records”;</p>
<pre><code>**CREATE** **TABLE** species_table (
    species text **PRIMARY** **KEY**,
    common_name text,
    population varint,
    average_size **int**,
    sex text,
) **WITH** **comment**='Some species records';
</code></pre>
<p>It is also possible to get the metadata from a table with the **DESCRIBE **statement.</p>
<pre><code>**DESCRIBE** **TABLES** | **TABLE** [keyspace_name.]table_name;
</code></pre>
<h3 id="dml_data_manipulation_language_"><a class="anchor" href="#dml_data_manipulation_language_">¶</a>DML (Data Manipulation Language)</h3>
<h4 id="insert_data"><a class="anchor" href="#insert_data">¶</a>Insert data</h4>
<p>Inserting data for a row is done using an **INSERT **statement:</p>
<pre><code>**INSERT** **INTO** table_name ( names_values | json_clause )
                      [ **IF** **NOT** **EXISTS** ]
                      [ **USING** update_parameter ( **AND** update_parameter )* ];
</code></pre>
<p>Where “names_values” is: names VALUES tuple_literal; “json_clause” is: JSON string [ DEFAULT ( NULL | UNSET ) ]; and “update_parameter” is usually: TTL.</p>
<p>For example we are going to use both VALUES and JSON clauses to insert data in the table “species_table”. In the VALUES clause it is necessary to supply the list of columns, not as in the JSON clause that is optional.</p>
<p>Note: TTL (Time To Live) and Timestamp are metrics for expiring data, so, when the time set is passed, the operation is expired.</p>
<p>In the VALUES clause we are going to insert a new specie called “White monkey”, with an average size of 3, its common name is “Copito de nieve”, population 0 and sex “male”.</p>
<pre><code>**INSERT** **INTO** species_table (species, common_name, population, average_size, sex)
                **VALUES** ('White monkey', 'Copito de nieve', 0, 3, 'male');
</code></pre>
<p>In the JSON clause we are going to insert a new specie called “Cloned sheep”, with an average size of 1, its common name is “Dolly the sheep”, population 0 and sex “female”.</p>
<pre><code>**INSERT** **INTO** species_table JSON '{&quot;species&quot;: &quot;Cloned Sheep&quot;,
                              &quot;common_name&quot;: &quot;Dolly the Sheep&quot;,
                              &quot;average_size&quot;:1,
                              &quot;population&quot;:0,
                              &quot;sex&quot;: &quot;female&quot;}';
</code></pre>
<p>Note: all updates for an **INSERT **are applied **atomically **and in <strong>isolation.</strong></p>
<h2 id="read"><a class="anchor" href="#read">¶</a>Read</h2>
<p>Querying data from data is done using a **SELECT **statement:</p>
<pre><code>**SELECT** [ JSON | **DISTINCT** ] ( select_clause | '*' )
                      **FROM** table_name
                      [ **WHERE** where_clause ]
                      [ **GROUP** **BY** group_by_clause ]
                      [ **ORDER** **BY** ordering_clause ]
                      [ PER **PARTITION** **LIMIT** (**integer** | bind_marker) ]
                      [ **LIMIT** (**integer** | bind_marker) ]
                      [ ALLOW FILTERING ];
</code></pre>
<p>The **CQL SELECT **statement is very **similar **to the **SQL SELECT **statement due to the fact that both allows filtering (<strong>WHERE</strong>), grouping data (<strong>GROUP BY</strong>), ordering the data (<strong>ORDER BY</strong>) and limit the number of data (<strong>LIMIT</strong>). Besides, **CQL offers **a **limit per partition **and allow the **filtering **of <strong>data</strong>.</p>
<p>Note: as in SQL it it possible to set alias to the data with the statement <strong>AS.</strong></p>
<p>For example we are going to retrieve all the information about those values from the tables “species_table” which “sex” is “male”. Allow filtering is mandatory when there is a WHERE statement.</p>
<pre><code>**SELECT** * **FROM** species_table **WHERE** sex = 'male' ALLOW FILTERING;
</code></pre>
<p><img src="s6GrKIGATvOSD7oGRNScUU5RnLN_-3X1JXvnVi_wDT_hrmPMZdnCdBI8DpIJ.png" alt="" />
<em>SELECT statement</em></p>
<p>Furthermore, we are going to test the SELECT JSON statement. For this, we are going to retrieve only the species name with a population of 0. </p>
<pre><code>**SELECT** JSON species **FROM** species_table **WHERE** population = 0 ALLOW FILTERING;
</code></pre>
<p><img src="Up_eHlqKQp2RI5XIbgPOvj1B5J3gLxz7v7EI0NDRgezQTipecdfDT6AQoso0.png" alt="" />
<em>SELECT JSON statement</em></p>
<h2 id="update"><a class="anchor" href="#update">¶</a>Update</h2>
<h3 id="ddl_data_definition_language__2"><a class="anchor" href="#ddl_data_definition_language__2">¶</a>DDL (Data Definition Language)</h3>
<h4 id="alter_keyspace"><a class="anchor" href="#alter_keyspace">¶</a>Alter keyspace</h4>
<p>The statement **ALTER KEYSPACE **allows to modify the options of a keyspace:</p>
<pre><code>**ALTER** KEYSPACE keyspace_name **WITH** options;
</code></pre>
<p>Note: the supported **options **are the same than for creating a keyspace, “<strong>replication</strong>” and “<strong>durable_writes</strong>”.</p>
<p>The example associated to this statement is to modify the keyspace with name “test_keyspace” and set a “replication_factor” of 4.</p>
<pre><code>**ALTER** KEYSPACE test_keyspace
    **WITH** **replication** = {'class': 'SimpleStrategy', 'replication_factor' : 4};
</code></pre>
<h4 id="alter_table"><a class="anchor" href="#alter_table">¶</a>Alter table</h4>
<p>Altering an existing table uses the **ALTER TABLE **statement:</p>
<pre><code>**ALTER** **TABLE** table_name alter_table_instruction;
</code></pre>
<p>Where “alter_table_instruction” can be: ADD column_name cql_type ( ‘,’ column_name cql_type )<em>; or DROP column_name ( column_name )</em>; or WITH options</p>
<p>The example associated to this statement is to ADD a new column to the table “species_table”, called “extinct” with type “boolean”.</p>
<pre><code>**ALTER** **TABLE** species_table **ADD** extinct **boolean**;
</code></pre>
<p>Another example is to DROP the column called “sex” from the table “species_table”.</p>
<pre><code>**ALTER** **TABLE** species_table **DROP** sex;
</code></pre>
<p>Finally, alter the comment with the WITH clause and set the comment to “All species records”. </p>
<pre><code>**ALTER** **TABLE** species_table **WITH** **comment**='All species records';
</code></pre>
<p>These changes can be checked with the **DESCRIBE **statement:</p>
<pre><code>**DESCRIBE** **TABLE** species_table;
</code></pre>
<p><img src="xebKPqkWkn97YVHpRVXZYWvRUfeRUyCH-vPDs67aFaEeU53YTRbDOFscOlAr.png" alt="" />
<em>DESCRIBE table</em></p>
<h3 id="dml_data_manipulation_language__2"><a class="anchor" href="#dml_data_manipulation_language__2">¶</a>DML (Data Manipulation Language)</h3>
<h4 id="update_data"><a class="anchor" href="#update_data">¶</a>Update data</h4>
<p>Updating a row is done using an **UPDATE **statement:</p>
<pre><code>**UPDATE** table_name
[ **USING** update_parameter ( **AND** update_parameter )* ]
**SET** assignment ( ',' assignment )*
**WHERE** where_clause
[ **IF** ( **EXISTS** | condition ( **AND** condition )*) ];
</code></pre>
<p>Where the update_parameter is: ( TIMESTAMP | TTL) (integer | bind_marker)</p>
<p>It is important to mention that the **WHERE **clause is used to select the row to update and **must <strong>include ** all columns</strong> composing the <strong>PRIMARY KEY.</strong></p>
<p>We are going to test this statement updating the column “extinct” to true to the column with name ‘White monkey’.</p>
<pre><code>**UPDATE** species_table **SET** extinct = **true** **WHERE** species='White monkey';
</code></pre>
<p><img src="IcaCe6VEC5c0ZQIygz-CiclzFyt491u7xPMg2muJLR8grmqaiUzkoQsVCoHf.png" alt="" />
<em>SELECT statement</em></p>
<h2 id="delete"><a class="anchor" href="#delete">¶</a>Delete</h2>
<h3 id="ddl_data_definition_language__3"><a class="anchor" href="#ddl_data_definition_language__3">¶</a>DDL (Data Definition Language)</h3>
<h4 id="drop_keyspace"><a class="anchor" href="#drop_keyspace">¶</a>Drop keyspace</h4>
<p>Dropping a keyspace can be done using the **DROP KEYSPACE **statement:</p>
<pre><code>**DROP** KEYSPACE [ **IF** **EXISTS** ] keyspace_name;
</code></pre>
<p>For example, drop the keyspace called “test_keyspace_2” if it exists:</p>
<pre><code>**DROP** KEYSPACE **IF** **EXISTS** test_keyspace_2;
</code></pre>
<p>As this keyspace does not exists, this sentence will do nothing.</p>
<h4 id="drop_table"><a class="anchor" href="#drop_table">¶</a>Drop table</h4>
<p>Dropping a table uses the **DROP TABLE **statement:</p>
<pre><code>**DROP** **TABLE** [ **IF** **EXISTS** ] table_name;
</code></pre>
<p>For example, drop the table called “species_2” if it exists: </p>
<pre><code>**DROP** **TABLE** **IF** **EXISTS** species_2;
</code></pre>
<p>As this table does not exists, this sentence will do nothing.</p>
<h4 id="truncate_table_"><a class="anchor" href="#truncate_table_">¶</a>Truncate (table)</h4>
<p>A table can be truncated using the **TRUNCATE **statement:</p>
<pre><code>**TRUNCATE** [ **TABLE** ] table_name;
</code></pre>
<p>Do not execute this command now, because if you do it, you will need to insert the previous data again.</p>
<p>Note: as tables are the only object that can be truncated the keyword TABLE can be omitted.</p>
<p><img src="FOkhfpxlWFQCzcdfeWxLTy7wx5inDv0xwVeVhE79Pqtk3yYzWsZJnz_SBhUi.png" alt="" />
<em>TRUNCATE statement</em></p>
<h3 id="dml_data_manipulation_language__3"><a class="anchor" href="#dml_data_manipulation_language__3">¶</a>DML (Data Manipulation Language)</h3>
<h4 id="delete_data"><a class="anchor" href="#delete_data">¶</a>Delete data</h4>
<p>Deleting rows or parts of rows uses the **DELETE **statement:</p>
<pre><code>**DELETE** [ simple_selection ( ',' simple_selection ) ]
                      **FROM** table_name
                      [ **USING** update_parameter ( **AND** update_parameter )* ]
                      **WHERE** where_clause
                      [ **IF** ( **EXISTS** | condition ( **AND** condition )*) ]
</code></pre>
<p>Now we are going to delete the value of the column “average_size” from “Cloned Sheep”. </p>
<pre><code>**DELETE** average_size **FROM** species_table **WHERE** species = 'Cloned Sheep';
</code></pre>
<p><img src="CyuQokVL5J9TAelq-WEWhNl6kFtbIYs0R1AeU5NX4EkG-YQI81mNHdnf2yWN.png" alt="" />
<em>DELETE value statement</em></p>
<p>And we are going to delete the same row as mentioned before. </p>
<pre><code>**DELETE** **FROM** species_table **WHERE** species = 'Cloned Sheep';
</code></pre>
<p><img src="jvQ5cXJ5GTVQ6giVhBEpPJmrJw-zwKKyB9nsTm5PRcGSTzkmh-WO4kTeuLpB.png" alt="" />
<em>DELETE row statement</em></p>
<h2 id="batch"><a class="anchor" href="#batch">¶</a>Batch</h2>
<p>Multiple <strong>INSERT</strong>, **UPDATE **and **DELETE **can be executed in a <strong>single statement</strong> by grouping them through a **BATCH **statement.</p>
<pre><code>**BEGIN** [ UNLOGGED | COUNTER ] BATCH
                            [ **USING** update_parameter ( **AND** update_parameter )* ]
                            modification_statement ( ';' modification_statement )*
                            APPLY BATCH;
</code></pre>
<p>Where modification_statement can be a insert_statement or an update_statement or a delete_statement.</p>
<ul>
<li>**UNLOGGED **means that either all operations in a batch eventually complete or none will.</li>
<li><strong>COUNTER</strong> means that the updates are not idempotent, so each time we execute the updates in a batch, we will have different results.
For example:</li>
</ul>
<pre><code>**BEGIN** BATCH
   **INSERT** **INTO** species_table (species, common_name, population, average_size, extinct)
                **VALUES** ('Blue Shark', 'Tiburillo', 30, 10, **false**);
   **INSERT** **INTO** species_table (species, common_name, population, average_size, extinct)
                **VALUES** ('Cloned sheep', 'Dolly the Sheep', 1, 1, **true**);
   **UPDATE** species_table **SET** population = 2 **WHERE** species='Cloned sheep';
   **DELETE** **FROM** species_table **WHERE** species =  'White monkey';
APPLY BATCH;
</code></pre>
<p><img src="EL9Dac26o0FqkVoeAKmopEKQe0wWq-xYI14b9RzGxtUkFJA3i2eTiR6qkuuJ.png" alt="" />
<em>BATCH statement</em></p>
<h2 id="index"><a class="anchor" href="#index">¶</a>Index</h2>
<p>CQL support creating secondary indexes on tables, allowing queries on the table to use those indexes. </p>
<p>**Creating **a secondary index on a table uses the **CREATE INDEX **statement:</p>
<pre><code>**CREATE** [ CUSTOM ] **INDEX** [ **IF** **NOT** **EXISTS** ] [ index_name ]
                                **ON** table_name '(' index_identifier ')'
                                [ **USING** string [ **WITH** OPTIONS = map_literal ] ];
</code></pre>
<p>For example we are going to create a index called “population_idx” that is related to the column “population” in the table “species_table”.</p>
<pre><code>**CREATE** **INDEX** population_idx **ON** species_table (population);
</code></pre>
<p>**Dropping **a secondary index uses the <strong>DROP INDEX</strong> statement: </p>
<pre><code>**DROP** **INDEX** [ **IF** **EXISTS** ] index_name;
</code></pre>
<p>Now, we are going to drop the previous index: </p>
<pre><code>**DROP** **INDEX** **IF** **EXISTS** population_idx;
</code></pre>
<h2 id="references"><a class="anchor" href="#references">¶</a>References</h2>
<ul>
<li><a href="https://cassandra.apache.org/doc/latest/cql/ddl.html">Cassandra CQL</a></li>
<li><a href="https://techdifferences.com/difference-between-ddl-and-dml-in-dbms.html">Differences between DML and DDL</a></li>
<li><a href="https://docs.datastax.com/en/dse/5.1/cql/cql/cql_reference/cqlReferenceTOC.html">Datastax CQL</a></li>
<li><a href="https://cassandra.apache.org/doc/latest/cql/types.html#grammar-token-cql-type">Cassandra CQL Types</a></li>
<li><a href="https://cassandra.apache.org/doc/latest/cql/indexes.html">Cassandra Index</a></li>
</ul>
</main>
</body>
</html>
 